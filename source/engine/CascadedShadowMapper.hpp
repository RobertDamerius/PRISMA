#pragma once


#include <Common.hpp>
#include <Camera.hpp>
#include <PrismaState.hpp>
#include <ShaderMeshShadowDepth.hpp>
#include <ShaderAlphaMeshShadowDepth.hpp>
#include <VectorUtils.hpp>
#include <PrismaConfiguration.hpp>


/**
 * @brief Represents the shadow mapper based on cascaded shadow mapping.
 */
class CascadedShadowMapper {
    public:
        /**
         * @brief Construct a new cascaded shadow mapper.
         */
        CascadedShadowMapper(): fbo(0), ubo(0), depthTextures(0), depthMapResolution(0){}

        /**
         * @brief Generate the cascaded shadow mapper.
         * @param[in] frustumSplitLevels Normalized values in range (0,1) that specify where to split the view frustum, e.g. {0.04, 0.1, 0.5}.
         * @param[in] bindingPointUBO Binding point for the uniform buffer object that stores the light projection-view matrices.
         * @param[in] depthMapResolution Image resolution of a depth map for each cascade, defaults to 4096.
         * @return True if success, false otherwise.
         */
        bool Generate(std::vector<GLfloat> frustumSplitLevels, GLuint bindingPointUBO, GLsizei depthMapResolution = 4096){
            // if shadow mapping is disabled, don't split the frustum and reduce memory to 1-by-1 pixel depth map
            if(!prismaConfiguration.engine.enableShadowMapping){
                frustumSplitLevels.clear();
                depthMapResolution = 1;
            }
            CalculateShadowCascadeLevels(frustumSplitLevels);
            GenerateUniformBufferObject(bindingPointUBO);
            bool success = GenerateFramebuffer(depthMapResolution);
            success &= shaderMeshShadowDepth.Generate(GetNumberOfCascades());
            success &= shaderAlphaMeshShadowDepth.Generate(GetNumberOfCascades());
            if(!success){
                Delete();
            }
            return success;
        }

        /**
         * @brief Delete the cascaded shadow mapper.
         */
        void Delete(void){
            DeleteFramebuffer();
            DeleteUniformBufferObject();
            shaderMeshShadowDepth.Delete();
            shaderAlphaMeshShadowDepth.Delete();
            shadowCascadeLevels.clear();
            farPlanes.clear();
        }

        /**
         * @brief Use the cascaded shadow mapper and bind the framebuffer.
         */
        void Use(void){
            DEBUG_GLCHECK( glBindFramebuffer(GL_FRAMEBUFFER, fbo); );
            DEBUG_GLCHECK( glViewport(0, 0, depthMapResolution, depthMapResolution); );
            DEBUG_GLCHECK( glClear(GL_DEPTH_BUFFER_BIT); );
            DEBUG_GLCHECK( glCullFace(GL_FRONT); ); // helps to prevent shadow acne
        }

        /**
         * @brief Draw the scene to the depth buffers of all cascades.
         * @param[in] prismaState The PRISMA state that contains the objects to be rendered.
         */
        void DrawScene(PrismaState& prismaState){
            UpdateLightMatrices(prismaState.atmosphere.GetSunLightDirection(), prismaState.camera);
            UpdateCascadeFarPlanes(prismaState.camera.clipNear, prismaState.camera.clipFar);
            prismaState.meshLibrary.DrawMeshShadows(prismaState.camera.position, totalLightMatrix, shaderMeshShadowDepth, shaderAlphaMeshShadowDepth);
            prismaState.dynamicMeshLibrary.DrawMeshShadows(prismaState.camera.position, totalLightMatrix, shaderMeshShadowDepth);
        }

        /**
         * @brief Get the number of cascades that have been generated by @ref Generate.
         * @return The number of cascades in use.
         */
        GLuint GetNumberOfCascades(void) const { return static_cast<GLuint>(shadowCascadeLevels.size()); }

        /**
         * @brief Get the texture ID for the depth texture array.
         * @return Texture ID of the depth texture array.
         */
        GLuint GetDepthTextureArray(void) const { return depthTextures; }

        /**
         * @brief Get the far planes of all cascades.
         * @return All far planes that have been calculated by the @ref DrawScene member function.
         */
        std::vector<GLfloat> GetCascadeFarPlanes(void) const { return farPlanes; }

    private:
        GLuint fbo;                                               // Framebuffer object.
        GLuint ubo;                                               // Uniform buffer object for the light matrices of all cascades.
        GLuint depthTextures;                                     // Texture ID of the depth texture array.
        GLsizei depthMapResolution;                               // Image resolution of the depthmap (used as width and height).
        std::vector<std::array<GLfloat,2>> shadowCascadeLevels;   // A pair of relative near-far values in range [0,1].
        std::vector<GLfloat> farPlanes;                           // List of all far planes (updated by @ref DrawScene).
        glm::mat4 totalLightMatrix;                               // Projection-view matrix of the light that contains the whole view camera frustum.
        ShaderMeshShadowDepth shaderMeshShadowDepth;              // Shader to be used for depth rendering of usual meshes of the scene.
        ShaderAlphaMeshShadowDepth shaderAlphaMeshShadowDepth;    // Shader to be used for depth rendering of alpha meshes of the scene.

        /**
         * @brief Calculate the projection-view matrices of the light for all cascades and update the uniform buffer.
         * @param[in] lightDirection The light direction.
         * @param[in] viewCamera The view camera.
         */
        void UpdateLightMatrices(glm::vec3 lightDirection, const Camera& viewCamera){
            std::vector<glm::mat4> lightMatrices = CalculateLightMatrices(lightDirection, viewCamera);
            DEBUG_GLCHECK( glBindBuffer(GL_UNIFORM_BUFFER, ubo); );
            for(size_t i = 0; i < lightMatrices.size(); ++i){
                DEBUG_GLCHECK( glBufferSubData(GL_UNIFORM_BUFFER, i * sizeof(glm::mat4), sizeof(glm::mat4), &lightMatrices[i]); );
            }
        }

        /**
         * @brief Update all far planes based on the near and far clipping plane of the view camera.
         * @param[in] clipNear The near clipping plane of the view camera.
         * @param[in] clipFar The far clipping plane of the view camera.
         */
        void UpdateCascadeFarPlanes(GLfloat clipNear, GLfloat clipFar){
            farPlanes.resize(shadowCascadeLevels.size());
            for(size_t i = 0; i < shadowCascadeLevels.size(); ++i){
                farPlanes[i] = clipNear + shadowCascadeLevels[i][1] * (clipFar - clipNear);
            }
        }

        /**
         * @brief Calculate the normalized shadow cascade levels.
         * @param[in] frustumSplitLevels Normalized values in range (0,1) that specify where to split the view frustum, e.g. {0.04, 0.1, 0.5}.
         */
        void CalculateShadowCascadeLevels(std::vector<GLfloat> frustumSplitLevels){
            // sort split levels in non-descending order
            std::sort(frustumSplitLevels.begin(), frustumSplitLevels.end());

            // create near-far pairs for each cascade
            shadowCascadeLevels.clear();
            GLfloat nearPlane = 0.0f;
            for(auto&& subdivisionLevel : frustumSplitLevels){
                if((subdivisionLevel > 0.0f) && (subdivisionLevel > nearPlane) && (subdivisionLevel < 1.0f)){
                    shadowCascadeLevels.push_back({nearPlane, subdivisionLevel});
                    nearPlane = subdivisionLevel;
                }
            }
            shadowCascadeLevels.push_back({nearPlane, 1.0f});
        }

        /**
         * @brief Calculate the projection-view-invCamView matrices for all cascades in @ref shadowCascadeLevels.
         * @param[in] lightDirection Light direction. The vector is normalized internally.
         * @param[in] viewCamera The view camera from which to obtain the frustum.
         * @return List of projection-view-invCamView matrices for all cascades.
         */
        std::vector<glm::mat4> CalculateLightMatrices(glm::vec3 lightDirection, const Camera& viewCamera){
            // ensure correctly normalized light direction
            lightDirection = VectorUtils::Normalize(lightDirection, glm::vec3(0.0f, -1.0f, 0.0f));

            // calculate light-up vector (for look-at matrix)
            glm::vec3 lightUpVector(1.0f, 0.0f, 0.0f);
            if(std::fabs(glm::dot(lightUpVector, lightDirection)) > 0.9f){
                lightUpVector = glm::vec3(0.0f, 0.0f, 1.0f);
            }

            // build total light matrix of whole frustum
            glm::mat4 V = viewCamera.GetViewMatrix();
            totalLightMatrix = glm::mat4(CalculateLightProjectionView(lightDirection, lightUpVector, V, viewCamera, {0.0f, 1.0f}));

            // build light matrices for all cascades
            glm::mat4 invV = glm::inverse(V);
            std::vector<glm::mat4> lightMatrices;
            for(auto&& cascadeLevel : shadowCascadeLevels){
                glm::mat4 lightProjectionView = CalculateLightProjectionView(lightDirection, lightUpVector, V, viewCamera, cascadeLevel);
                lightMatrices.push_back(glm::mat4(lightProjectionView * invV));
            }
            return lightMatrices;
        }

        /**
         * @brief Calculate the projection-view matrix for a specific cascade.
         * @param[in] lightDirection The light direction.
         * @param[in] lightUpVector The up-vector of the light frustum.
         * @param[in] cameraViewMatrix The view matrix of the view camera.
         * @param[in] viewCamera The view camera.
         * @param[in] cascadeLevel The normalized cascade level {near, far} in range [0,1].
         * @return Projection-view matrix of the given cascade.
         */
        glm::mat4 CalculateLightProjectionView(const glm::vec3& lightDirection, const glm::vec3& lightUpVector, const glm::mat4& cameraViewMatrix, const Camera& viewCamera, const std::array<GLfloat,2>& cascadeLevel){
            glm::mat4 P = GetProjectionOfCascadeLevel(viewCamera, cascadeLevel);
            glm::mat4 frustumInversePV = glm::inverse(P * cameraViewMatrix);
            std::vector<glm::vec4> frustumCorners = GetFrustumCornersWorldSpace(frustumInversePV);
            return GetLightProjectionViewFromFrustumCorners(frustumCorners, lightDirection, lightUpVector, viewCamera.clipFar);
        }

        /**
         * @brief Get the projection matrix for a specific cascade level.
         * @param[in] viewCamera The view camera.
         * @param[in] cascadeLevel The normalized cascade level {near, far} in range [0,1].
         * @return The projection matrix of the cascade level.
         */
        glm::mat4 GetProjectionOfCascadeLevel(const Camera& viewCamera, const std::array<GLfloat,2>& cascadeLevel){
            GLfloat clipRange = viewCamera.clipFar - viewCamera.clipNear;
            GLfloat clipNear = viewCamera.clipNear + cascadeLevel[0] * clipRange;
            GLfloat clipFar = viewCamera.clipNear + cascadeLevel[1] * clipRange;
            glm::mat4 projectionMatrix(1.0f);
            switch(viewCamera.mode){
                case CAMERA_MODE_PERSPECTIVE:
                    projectionMatrix = glm::perspective(viewCamera.perspectiveFieldOfView, viewCamera.GetAspectRatio(), clipNear, clipFar);
                    break;
                case CAMERA_MODE_ORTHOGRAPHIC:
                    projectionMatrix = glm::ortho(viewCamera.orthographicLeft, viewCamera.orthographicRight, viewCamera.orthographicBottom, viewCamera.orthographicTop, clipNear, clipFar);
                    break;
            }
            return projectionMatrix;
        }

        /**
         * @brief Get the world-space corner points of a frustum.
         * @param[in] frustumInverseProjectionViewMatrix Inverse of the projection-view matrix that indicates the frustum for which to obtain the corner points.
         * @return All world-space corner points of the frustum.
         */
        std::vector<glm::vec4> GetFrustumCornersWorldSpace(const glm::mat4& frustumInverseProjectionViewMatrix){
            std::vector<glm::vec4> frustumCorners;
            for(int32_t x = 0; x < 2; ++x){
                for(int32_t y = 0; y < 2; ++y){
                    for(int32_t z = 0; z < 2; ++z){
                        glm::vec4 point = frustumInverseProjectionViewMatrix * glm::vec4(2.0f * x - 1.0f, 2.0f * y - 1.0f, 2.0f * z - 1.0f, 1.0f);
                        frustumCorners.push_back(point / point.w);
                    }
                }
            }
            return frustumCorners;
        }

        /**
         * @brief Get the light projection-view matrix from given world-space corner points of a frustum.
         * @param[in] frustumCorners World-space corners of the frustum.
         * @param[in] lightDirection Light direction.
         * @param[in] lightUpVector The up-vector of the light frustum.
         * @param[in] viewCameraClipFar Far clipping plane of the view camera.
         * @return Projection-view matrix of the light.
         */
        glm::mat4 GetLightProjectionViewFromFrustumCorners(const std::vector<glm::vec4>& frustumCorners, const glm::vec3& lightDirection, const glm::vec3& lightUpVector, GLfloat viewCameraClipFar){
            // view matrix
            glm::mat4 lightView = glm::lookAt(glm::vec3(0.0f), lightDirection, lightUpVector);

            // get limits for orthographic projection matrix
            glm::vec3 lowerLimit(std::numeric_limits<GLfloat>::max());
            glm::vec3 upperLimit(std::numeric_limits<GLfloat>::lowest());
            for(auto&& point : frustumCorners){
                glm::vec4 p = lightView * point;
                lowerLimit.x = std::min(lowerLimit.x, p.x);
                lowerLimit.y = std::min(lowerLimit.y, p.y);
                lowerLimit.z = std::min(lowerLimit.z, p.z);
                upperLimit.x = std::max(upperLimit.x, p.x);
                upperLimit.y = std::max(upperLimit.y, p.y);
                upperLimit.z = std::max(upperLimit.z, p.z);
            }
            upperLimit.z += viewCameraClipFar;

            // final projection view matrix
            GLfloat zNear = -upperLimit.z;
            GLfloat zFar = -lowerLimit.z;
            glm::mat4 lightProjection = glm::ortho(lowerLimit.x, upperLimit.x, lowerLimit.y, upperLimit.y, zNear, zFar); // ortho uses lfet-handed coordinate system: z is defined in view direction
            return lightProjection * lightView;
        }

        /**
         * @brief Generate the framebuffer and the depth texture array for the cascaded shadow mapper.
         * @param[in] depthMapResolution Resolution of a depth map image (used as width and height).
         * @return True if success, false otherwise.
         */
        bool GenerateFramebuffer(GLsizei depthMapResolution){
            DEBUG_GLCHECK( glGenFramebuffers(1, &fbo); );
            DEBUG_GLCHECK( glGenTextures(1, &depthTextures); );
            DEBUG_GLCHECK( glBindTexture(GL_TEXTURE_2D_ARRAY, depthTextures); );
            DEBUG_GLCHECK( glTexImage3D(GL_TEXTURE_2D_ARRAY, 0, GL_DEPTH_COMPONENT32F, depthMapResolution, depthMapResolution, static_cast<GLsizei>(shadowCascadeLevels.size()), 0, GL_DEPTH_COMPONENT, GL_FLOAT, nullptr); );
            DEBUG_GLCHECK( glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST); );
            DEBUG_GLCHECK( glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST); );
            DEBUG_GLCHECK( glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER); );
            DEBUG_GLCHECK( glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER); );
            constexpr GLfloat bordercolor[] = { 1.0f, 1.0f, 1.0f, 1.0f };
            DEBUG_GLCHECK( glTexParameterfv(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_BORDER_COLOR, bordercolor); );
            DEBUG_GLCHECK( glBindFramebuffer(GL_FRAMEBUFFER, fbo); );
            DEBUG_GLCHECK( glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthTextures, 0); );
            DEBUG_GLCHECK( glDrawBuffer(GL_NONE); );
            DEBUG_GLCHECK( glReadBuffer(GL_NONE); );
            // check status
            if(GL_FRAMEBUFFER_COMPLETE != glCheckFramebufferStatus(GL_FRAMEBUFFER)){
                PrintE("Framebuffer for cascaded shadow mapper is not complete!\n");
                DeleteFramebuffer();
                return false;
            }
            this->depthMapResolution = depthMapResolution;
            return true;
        }

        /**
         * @brief Delete the framebuffer and the depth texture array.
         */
        void DeleteFramebuffer(void){
            if(depthTextures){
                DEBUG_GLCHECK( glDeleteTextures(1, &depthTextures); );
                depthTextures = 0;
            }
            if(fbo){
                DEBUG_GLCHECK( glDeleteFramebuffers(1, &fbo); );
                fbo = 0;
            }
            depthMapResolution = 0;
        }

        /**
         * @brief Generate the uniform buffer object.
         * @param[in] bindingPoint The bining point for the uniform buffer object. Must be the same in the shader.
         * @details The shader must use the following uniform block:
         * layout (std140, binding = $UBO_LIGHTMATRICES$) uniform LightSpaceMatrices {
         *     mat4 lightSpaceMatrices[$NUMBER_OF_SHADOW_CASCADES$];
         * };
         */
        void GenerateUniformBufferObject(GLuint bindingPoint){
            DEBUG_GLCHECK( glGenBuffers(1, &ubo); );
            DEBUG_GLCHECK( glBindBuffer(GL_UNIFORM_BUFFER, ubo); );
            DEBUG_GLCHECK( glBufferData(GL_UNIFORM_BUFFER, sizeof(glm::mat4) * shadowCascadeLevels.size(), nullptr, GL_DYNAMIC_DRAW); );
            DEBUG_GLCHECK( glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, ubo); );
        }

        /**
         * @brief Delete the uniform buffer object.
         */
        void DeleteUniformBufferObject(void){
            if(ubo){
                DEBUG_GLCHECK( glDeleteBuffers(1, &ubo); );
                ubo = 0;
            }
        }
};

