#pragma once


#include <Common.hpp>
#include <LightID.hpp>
#include <AmbientLight.hpp>
#include <DirectionalLight.hpp>
#include <PointLight.hpp>
#include <SpotLight.hpp>
#include <AmbientLightMessage.hpp>
#include <DirectionalLightMessage.hpp>
#include <PointLightMessage.hpp>
#include <SpotLightMessage.hpp>
#include <Camera.hpp>
#include <CuboidFrustumCuller.hpp>


/**
 * @brief This class represents the light library that contains all light casters. The light library manages
 * three shader storage buffer objects that contain the data of all light casters.
 */
class LightLibrary {
    public:
        /**
         * @brief Construct a new light library.
         */
        LightLibrary(): ssboDirectionalLights(0), ssboPointLights(0), ssboSpotLights(0), maxNumDirectionalLights(0), maxNumPointLights(0), maxNumSpotLights(0){}

        /**
         * @brief Generate the light library and all its GL content.
         * @param[in] bindingPointDirectionalLights The bining point for the shader storage buffer object that contains directional light data.
         * @param[in] bindingPointPointLights The bining point for the shader storage buffer object that contains point light data.
         * @param[in] bindingPointSpotLights The bining point for the shader storage buffer object that contains spot light data.
         * @param[in] maxNumDirectionalLights The maximum number of directional lights that should be used for rendering.
         * @param[in] maxNumPointLights The maximum number of point lights that should be used for rendering.
         * @param[in] maxNumSpotLights The maximum number of spot lights that should be used for rendering.
         */
        void Generate(GLuint bindingPointDirectionalLights, GLuint bindingPointPointLights, GLuint bindingPointSpotLights, GLuint maxNumDirectionalLights, GLuint maxNumPointLights, GLuint maxNumSpotLights){
            GenerateShaderStorageBufferObjects(bindingPointDirectionalLights, bindingPointPointLights, bindingPointSpotLights, maxNumDirectionalLights, maxNumPointLights, maxNumSpotLights);
        }

        /**
         * @brief Delete the light library and delete all GL content that has been generated by @ref Generate.
         */
        void Delete(void){
            DeleteShaderStorageBufferObjects();
            Clear();
        }

        /**
         * @brief Clear the light library by removing all light casters.
         */
        void Clear(void){
            ambientLight.Clear();
            directionalLights.clear();
            pointLights.clear();
            spotLights.clear();
        }

        /**
         * @brief Process an ambient light message and update the internal ambient light.
         * @param[in] message The ambient light message to be processed.
         */
        void ProcessAmbientLightMessage(const AmbientLightMessage& message){
            ambientLight = message.ambientLight;
        }

        /**
         * @brief Process a directional light message and update the internal container of directional lights.
         * @param[in] message The directional light message to be processed.
         */
        void ProcessDirectionalLightMessage(const DirectionalLightMessage& message){
            if(message.shouldBeDeleted){
                DeleteDirectionalLight(message.directionalLightID);
            }
            else{
                directionalLights.insert_or_assign(message.directionalLightID, message.directionalLight);
            }
        }

        /**
         * @brief Process a point light messages and update the internal container of point lights.
         * @param[in] message The point light messages to be processed.
         */
        void ProcessPointLightMessage(const PointLightMessage& message){
            if(message.shouldBeDeleted){
                DeletePointLight(message.pointLightID);
            }
            else{
                pointLights.insert_or_assign(message.pointLightID, message.pointLight);
            }
        }

        /**
         * @brief Process a spot light messages and update the internal container of spot lights.
         * @param[in] message The spot light messages to be processed.
         */
        void ProcessSpotLightMessage(const SpotLightMessage& message){
            if(message.shouldBeDeleted){
                DeleteSpotLight(message.spotLightID);
            }
            else{
                spotLights.insert_or_assign(message.spotLightID, message.spotLight);
            }
        }

        /**
         * @brief Apply all visible light casters to the environment shader.
         * @param[in] shader The environment shader.
         * @param[in] camera The view camera that is used for sorting the lights before rendering.
         */
        template <class T> void ApplyVisibleLights(const T& shader, const Camera& camera){
            // get view matrix for view space transformation
            glm::mat4 viewMatrix = camera.GetViewMatrix();
            glm::mat3 translationFreeViewMatrix = glm::mat3(viewMatrix);

            // sort lights and update SSBOs
            auto [directionalLightsToApply, pointLightsToApply, spotLightsToApply] = SortLightCasters(camera);
            GLuint numDirectionalLights = UpdateDirectionalLightData(directionalLightsToApply, translationFreeViewMatrix);
            GLuint numPointLights = UpdatePointLightData(pointLightsToApply, viewMatrix);
            GLuint numSpotLights = UpdateSpotLightData(spotLightsToApply, viewMatrix, translationFreeViewMatrix);
            shader.SetNumDirectionalLights(numDirectionalLights);
            shader.SetNumPointLights(numPointLights);
            shader.SetNumSpotLights(numSpotLights);

            // apply ambient light
            shader.SetAmbientLightColor(ambientLight.color);
        }

    private:
        GLuint ssboDirectionalLights;                                                 // The internal shader storage buffer object for directional lights.
        GLuint ssboPointLights;                                                       // The internal shader storage buffer object for point lights.
        GLuint ssboSpotLights;                                                        // The internal shader storage buffer object for spot lights.
        GLuint maxNumDirectionalLights;                                               // The maximum number of directional lights the @ref ssboDirectionalLights can store.
        GLuint maxNumPointLights;                                                     // The maximum number of point lights the @ref ssboPointLights can store.
        GLuint maxNumSpotLights;                                                      // The maximum number of spot lights the @ref ssboSpotLights can store.
        std::vector<GLfloat> buffer;                                                  // A temporary buffer that is used to copy data to the SSBOs.
        AmbientLight ambientLight;                                                    // Data of one ambient light.
        std::unordered_map<DirectionalLightID, DirectionalLight> directionalLights;   // Container of all directional lights.
        std::unordered_map<PointLightID, PointLight> pointLights;                     // Container of all point lights.
        std::unordered_map<SpotLightID, SpotLight> spotLights;                        // Container of all spot lights.

        /**
         * @brief Generate all shader storage buffer objects for point light and spot light data.
         * @param[in] bindingPointDirectionalLights The bining point for the shader storage buffer object that contains directional light data.
         * @param[in] bindingPointPointLights The bining point for the shader storage buffer object that contains point light data.
         * @param[in] bindingPointSpotLights The bining point for the shader storage buffer object that contains spot light data.
         * @param[in] maxNumDirectionalLights The maximum number of directional lights that should be used for rendering.
         * @param[in] maxNumPointLights The maximum number of point lights that should be used for rendering.
         * @param[in] maxNumSpotLights The maximum number of spot lights that should be used for rendering.
         */
        void GenerateShaderStorageBufferObjects(GLuint bindingPointDirectionalLights, GLuint bindingPointPointLights, GLuint bindingPointSpotLights, GLuint maxNumDirectionalLights, GLuint maxNumPointLights, GLuint maxNumSpotLights){
            constexpr size_t binarySizeOfADirectionalLight = 6 * sizeof(GLfloat);
            constexpr size_t binarySizeOfAPointLight = 8 * sizeof(GLfloat);
            constexpr size_t binarySizeOfASpotLight = 13 * sizeof(GLfloat);
            this->maxNumDirectionalLights = maxNumDirectionalLights;
            this->maxNumPointLights = maxNumPointLights;
            this->maxNumSpotLights = maxNumSpotLights;
            size_t bufferSizeDirectionalLights = binarySizeOfADirectionalLight * static_cast<size_t>(this->maxNumDirectionalLights);
            size_t bufferSizePointLights = binarySizeOfAPointLight * static_cast<size_t>(this->maxNumPointLights);
            size_t bufferSizeSpotLights = binarySizeOfASpotLight * static_cast<size_t>(this->maxNumSpotLights);
            DEBUG_GLCHECK( glGenBuffers(1, &ssboDirectionalLights); );
            DEBUG_GLCHECK( glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssboDirectionalLights); );
            DEBUG_GLCHECK( glBufferData(GL_SHADER_STORAGE_BUFFER, bufferSizeDirectionalLights, nullptr, GL_DYNAMIC_DRAW); );
            DEBUG_GLCHECK( glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0); );
            DEBUG_GLCHECK( glBindBufferBase(GL_SHADER_STORAGE_BUFFER, bindingPointDirectionalLights, ssboDirectionalLights); );
            DEBUG_GLCHECK( glGenBuffers(1, &ssboPointLights); );
            DEBUG_GLCHECK( glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssboPointLights); );
            DEBUG_GLCHECK( glBufferData(GL_SHADER_STORAGE_BUFFER, bufferSizePointLights, nullptr, GL_DYNAMIC_DRAW); );
            DEBUG_GLCHECK( glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0); );
            DEBUG_GLCHECK( glBindBufferBase(GL_SHADER_STORAGE_BUFFER, bindingPointPointLights, ssboPointLights); );
            DEBUG_GLCHECK( glGenBuffers(1, &ssboSpotLights); );
            DEBUG_GLCHECK( glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssboSpotLights); );
            DEBUG_GLCHECK( glBufferData(GL_SHADER_STORAGE_BUFFER, bufferSizeSpotLights, nullptr, GL_DYNAMIC_DRAW); );
            DEBUG_GLCHECK( glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0); );
            DEBUG_GLCHECK( glBindBufferBase(GL_SHADER_STORAGE_BUFFER, bindingPointSpotLights, ssboSpotLights); );
            buffer.resize(std::max(std::max(bufferSizeDirectionalLights, bufferSizePointLights), bufferSizeSpotLights));
        }

        /**
         * @brief Delete all shader storage buffer objects for point light and spot light data.
         */
        void DeleteShaderStorageBufferObjects(void){
            if(ssboDirectionalLights){
                DEBUG_GLCHECK( glDeleteBuffers(1, &ssboDirectionalLights); );
                ssboDirectionalLights = 0;
            }
            if(ssboPointLights){
                DEBUG_GLCHECK( glDeleteBuffers(1, &ssboPointLights); );
                ssboPointLights = 0;
            }
            if(ssboSpotLights){
                DEBUG_GLCHECK( glDeleteBuffers(1, &ssboSpotLights); );
                ssboSpotLights = 0;
            }
            maxNumDirectionalLights = 0;
            maxNumPointLights = 0;
            maxNumSpotLights = 0;
            buffer.clear();
            buffer.shrink_to_fit();
        }

        /**
         * @brief Update the SSBO for directional light data.
         * @param[in] lights List of directional lights to be used to update the data.
         * @param[in] translationFreeViewMatrix Camera view matrix without translation.
         * @return The number of directional lights that have been assigned to the SSBO.
         */
        GLuint UpdateDirectionalLightData(std::vector<DirectionalLight>& lights, glm::mat3 translationFreeViewMatrix){
            if(lights.size() > static_cast<size_t>(maxNumDirectionalLights)){
                lights.resize(maxNumDirectionalLights);
            }
            GLuint numberOfLights = static_cast<GLuint>(lights.size());
            if(numberOfLights){
                size_t numFloats = 0;
                for(size_t i = 0; i < lights.size(); ++i){
                    glm::vec3 viewSpaceDirection = glm::vec3(translationFreeViewMatrix * lights[i].direction);
                    buffer[numFloats++] = lights[i].color.r;
                    buffer[numFloats++] = lights[i].color.g;
                    buffer[numFloats++] = lights[i].color.b;
                    buffer[numFloats++] = viewSpaceDirection.x;
                    buffer[numFloats++] = viewSpaceDirection.y;
                    buffer[numFloats++] = viewSpaceDirection.z;
                }
                DEBUG_GLCHECK( glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssboDirectionalLights); );
                DEBUG_GLCHECK( glBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, numFloats * sizeof(GLfloat), &buffer[0]); );
            }
            return numberOfLights;
        }

        /**
         * @brief Update the SSBO for point light data.
         * @param[in] lights List of point lights to be used to update the data.
         * @param[in] viewMatrix Camera view matrix.
         * @return The number of point lights that have been assigned to the SSBO.
         */
        GLuint UpdatePointLightData(std::vector<PointLight>& lights, glm::mat4 viewMatrix){
            if(lights.size() > static_cast<size_t>(maxNumPointLights)){
                lights.resize(maxNumPointLights);
            }
            GLuint numberOfLights = static_cast<GLuint>(lights.size());
            if(numberOfLights){
                size_t numFloats = 0;
                for(size_t i = 0; i < lights.size(); ++i){
                    glm::vec3 viewSpacePosition = glm::vec3(viewMatrix * glm::vec4(lights[i].position, 1.0f));
                    buffer[numFloats++] = lights[i].color.r;
                    buffer[numFloats++] = lights[i].color.g;
                    buffer[numFloats++] = lights[i].color.b;
                    buffer[numFloats++] = viewSpacePosition.x;
                    buffer[numFloats++] = viewSpacePosition.y;
                    buffer[numFloats++] = viewSpacePosition.z;
                    buffer[numFloats++] = lights[i].invRadiusPow4;
                    buffer[numFloats++] = lights[i].quadraticFalloff;
                }
                DEBUG_GLCHECK( glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssboPointLights); );
                DEBUG_GLCHECK( glBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, numFloats * sizeof(GLfloat), &buffer[0]); );
            }
            return numberOfLights;
        }

        /**
         * @brief Update the SSBO for spot light data.
         * @param[in] lights List of spot lights to be used to update the data.
         * @param[in] viewMatrix Camera view matrix.
         * @param[in] translationFreeViewMatrix Camera view matrix without translation.
         * @return The number of spot lights that have been assigned to the SSBO.
         */
        GLuint UpdateSpotLightData(std::vector<SpotLight>& lights, glm::mat4 viewMatrix, glm::mat3 translationFreeViewMatrix){
            if(lights.size() > static_cast<size_t>(maxNumSpotLights)){
                lights.resize(maxNumSpotLights);
            }
            GLuint numberOfLights = static_cast<GLuint>(lights.size());
            if(numberOfLights){
                size_t numFloats = 0;
                for(size_t i = 0; i < lights.size(); ++i){
                    glm::vec3 viewSpacePosition = glm::vec3(viewMatrix * glm::vec4(lights[i].position, 1.0f));
                    glm::vec3 viewSpaceDirection = glm::vec3(translationFreeViewMatrix * lights[i].direction);
                    buffer[numFloats++] = lights[i].color.r;
                    buffer[numFloats++] = lights[i].color.g;
                    buffer[numFloats++] = lights[i].color.b;
                    buffer[numFloats++] = viewSpacePosition.x;
                    buffer[numFloats++] = viewSpacePosition.y;
                    buffer[numFloats++] = viewSpacePosition.z;
                    buffer[numFloats++] = viewSpaceDirection.x;
                    buffer[numFloats++] = viewSpaceDirection.y;
                    buffer[numFloats++] = viewSpaceDirection.z;
                    buffer[numFloats++] = lights[i].invRadiusPow4;
                    buffer[numFloats++] = lights[i].quadraticFalloff;
                    buffer[numFloats++] = lights[i].cosInnerCutOffAngle;
                    buffer[numFloats++] = lights[i].cosOuterCutOffAngle;
                }
                DEBUG_GLCHECK( glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssboSpotLights); );
                DEBUG_GLCHECK( glBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, numFloats * sizeof(GLfloat), &buffer[0]); );
            }
            return numberOfLights;
        }

        /**
         * @brief Sort all light casters that are visible according to their distance to the camera.
         * @return A tuple containing the following values:
         * [0] Vector of directional lights to be applied.
         * [1] Vector of point lights to be applied.
         * [2] Vector of spot lights to be applied.
         */
        std::tuple<std::vector<DirectionalLight>, std::vector<PointLight>, std::vector<SpotLight>> SortLightCasters(const Camera& camera){
            std::tuple<std::vector<DirectionalLight>, std::vector<PointLight>, std::vector<SpotLight>> result;
            std::vector<DirectionalLight>& directionalLightsToApply = std::get<0>(result);
            std::vector<PointLight>& pointLightsToApply = std::get<1>(result);
            std::vector<SpotLight>& spotLightsToApply = std::get<2>(result);
            glm::mat4 cameraProjectionView = camera.GetProjectionViewMatrix();
            CuboidFrustumCuller culler(cameraProjectionView);

            // copy visible directional lights to output
            directionalLightsToApply.clear();
            for(auto& itDirectionalLight : directionalLights){
                const DirectionalLight& light = itDirectionalLight.second;
                if(light.visible){
                    directionalLightsToApply.push_back(light);
                }
            }

            // get all visible point lights, sort them by distance and copy them to the output
            std::vector<std::pair<double,PointLight>> visiblePointLights;
            for(auto& itPointLight : pointLights){
                // ignore invisible lights
                const PointLight& light = itPointLight.second;
                if(!light.visible){
                    continue;
                }

                // ignore lights that are not visible by the camera
                AABB cuboid = light.CalculateAABB();
                if(!culler.IsVisible(cuboid)){
                    continue;
                }

                // calculate distance to camera and insert to output
                double squaredDistance = CalculateSquaredLightDistance(light.position, camera);
                visiblePointLights.push_back({squaredDistance, light});
            }
            std::sort(visiblePointLights.begin(), visiblePointLights.end(), [](std::pair<double,PointLight> a, std::pair<double,PointLight> b){ return a.first < b.first; });
            pointLightsToApply.clear();
            for(auto&& visibleLight : visiblePointLights){
                pointLightsToApply.push_back(visibleLight.second);
            }

            // get all visible spot lights, sort them by distance and copy them to the output
            std::vector<std::pair<double,SpotLight>> visibleSpotLights;
            for(auto& itSpotLight : spotLights){
                // ignore invisible lights
                const SpotLight& light = itSpotLight.second;
                if(!light.visible){
                    continue;
                }

                // ignore lights that are not visible by the camera
                AABB cuboid = light.CalculateAABB();
                if(!culler.IsVisible(cuboid)){
                    continue;
                }

                // calculate distance to camera and insert to output
                double squaredDistance = CalculateSquaredLightDistance(light.position, camera);
                visibleSpotLights.push_back({squaredDistance, light});
            }
            std::sort(visibleSpotLights.begin(), visibleSpotLights.end(), [](std::pair<double,SpotLight> a, std::pair<double,SpotLight> b){ return a.first < b.first; });
            spotLightsToApply.clear();
            for(auto&& visibleLight : visibleSpotLights){
                spotLightsToApply.push_back(visibleLight.second);
            }
            return result;
        }

        /**
         * @brief Delete a directional light from @ref directionalLights.
         * @param[in] id The identifier of the directional light to be deleted.
         */
        void DeleteDirectionalLight(const DirectionalLightID id){
            auto it = directionalLights.find(id);
            if(it != directionalLights.end()){
                directionalLights.erase(it);
            }
        }

        /**
         * @brief Delete a point light from @ref pointLights.
         * @param[in] id The identifier of the point light to be deleted.
         */
        void DeletePointLight(const PointLightID id){
            auto it = pointLights.find(id);
            if(it != pointLights.end()){
                pointLights.erase(it);
            }
        }

        /**
         * @brief Delete a spot light from @ref spotLights.
         * @param[in] id The identifier of the spot light to be deleted.
         */
        void DeleteSpotLight(const SpotLightID id){
            auto it = spotLights.find(id);
            if(it != spotLights.end()){
                spotLights.erase(it);
            }
        }

        /**
         * @brief Calculate the squared distance from the camera to the light.
         * @param[in] lightPosition The position of the light.
         * @param[in] camera The camera from which to calculate the distance to the light.
         * @return Squared distance from the camera position to the light position.
         */
        double CalculateSquaredLightDistance(glm::vec3 lightPosition, const Camera& camera){
            double dx = static_cast<double>(lightPosition.x) - static_cast<double>(camera.position.x);
            double dy = static_cast<double>(lightPosition.y) - static_cast<double>(camera.position.y);
            double dz = static_cast<double>(lightPosition.z) - static_cast<double>(camera.position.z);
            return dx*dx + dy*dy + dz*dz;
        }
};

